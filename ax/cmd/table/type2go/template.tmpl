// Code generated by Minotaur-AX CLI v0.6.1. DO NOT EDIT.

package main

import (
    "sync"
    "errors"
    "fmt"
    "encoding/json"
)

var lock sync.RWMutex

const (
    {{- range .Vars}}
        {{- if .HasDesc}}
            // {{.Name}}Sign {{.Desc}}签名
        {{- end}}
        {{.Name}}Sign = "{{.Name}}"
    {{- end}}
)

var (
    {{- range .Vars}}
        {{- if .HasDesc}}
            // {{.Name}} {{.Desc}}
        {{- end}}
        _{{.Name}} {{.Type}}
        ready{{.Name}} {{.Type}}
    {{- end}}
)

{{range .Structs}}
    {{- if .HasDesc}}
        // {{.Name}} {{.Desc}}
    {{- end}}
    type {{.Name}} struct {
        {{- range .Fields}}
            {{- if .HasDesc}}
                {{.Name}} {{.Type}} // {{.Desc}}
            {{- else}}
                {{.Name}} {{.Type}}
            {{- end}}
        {{- end}}
    }
{{end}}

// RefreshAllConfig 刷新所有配置，使用已准备就绪的配置覆盖线上配置
func RefreshAllConfig() (err error) {
    lock.Lock()
    defer lock.Unlock()

    var rollbacks []func()

    {{- range .Vars}}
        if ready{{.Name}} == nil {
            err = errors.New("ready{{.Name}} is nil")
            return
        }
        backup := _{{.Name}}
        rollbacks = append(rollbacks, func() {
            _{{.Name}} = backup
        })
        _{{.Name}} = ready{{.Name}}
    {{- end}}

    if err != nil {
        for _, rollback := range rollbacks {
            rollback()
        }
    }

    return err
}

// RefreshConfigWithSign 刷新配置，使用已准备就绪的配置更替线上配置
func RefreshConfigWithSign(sign string) error {
    lock.Lock()
    defer lock.Unlock()

    switch sign {
    {{- range .Vars}}
        case {{.Name}}Sign:
            config := ready{{.Name}}
            if config == nil {
                return errors.New("config is nil")
            }
            _{{.Name}} = config
    {{- end}}
    default:
        return errors.New("invalid config sign")
    }
    return nil
}

// SetConfigReadyWithSign 通过签名设置已准备就绪的配置
//  - 当配置执行更新时，准备就绪的配置将会上线
func SetConfigReadyWithSign(sign string, config any) error {
    lock.Lock()
    defer lock.Unlock()

    switch sign {
    {{- range .Vars}}
        case {{.Name}}Sign:
            v, ok := config.(*{{.Type}})
            if !ok {
                return fmt.Errorf("invalid config type, expect *{{.Type}}, got %T", config)
            }
            ready{{.Name}} = v
    {{- end}}
    default:
        return errors.New("invalid config sign")
    }
}

// GetConfigWithSign 通过签名获取配置
//   - 该函数将返回线上配置的指针，修改将会导致不可预测的结果，如果需要安全的修改，可使用 GetConfigWithSignCopy 函数
func GetConfigWithSign(sign string) (any, error) {
    lock.RLock()
    defer lock.RUnlock()

    switch sign {
    {{- range .Vars}}
        case {{.Name}}Sign:
            return _{{.Name}}, nil
    {{- end}}
    default:
        return nil, errors.New("invalid config sign")
    }
    return nil
}

// GetConfigWithSignCopy 获取配置
func GetConfigWithSignCopy(sign string) (any, error) {
    lock.RLock()
    defer lock.RUnlock()

    switch sign {
    {{- range .Vars}}
        case {{.Name}}Sign:

            {{- if .IsMake}}
                copy := make({{.Type}})
            {{- else}}
                copy := new({{.Type}})
            {{- end}}
            bytes, _ := json.Marshal(_{{.Name}}, copy)
            _ = json.Unmarshal(bytes, copy)
            return copy, nil
    {{- end}}
    default:
        return nil, errors.New("invalid config sign")
    }
}

{{range .Vars}}
    // Get{{.Name}} 获取{{.Desc}}配置
    //   - 该函数将返回线上配置的指针，修改将会导致不可预测的结果，如果需要安全的修改，可使用 Get{{.Name}}Copy 函数
    func Get{{.Name}}() {{.Type}} {
        lock.RLock()
        defer lock.RUnlock()
        return _{{.Name}}
    }

    // Get{{.Name}}Copy 获取{{.Desc}}配置
    //   - 该函数将返回线上配置的拷贝，修改不会影响线上配置
    func Get{{.Name}}Copy() {{.Type}} {
        lock.RLock()
        defer lock.RUnlock()

        {{- if .IsMake}}
            copy := make({{.Type}})
        {{- else}}
            copy := new({{.Type}})
        {{- end}}
        bytes, _ := json.Marshal(_{{.Name}}, copy)
        _ = json.Unmarshal(bytes, copy)
        return copy
    }
{{end}}