package generator

import (
	"fmt"
	"github.com/kercylan98/minotaur/engine/vivid/typed/options"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

const (
	GenerateModeCluster      = "cluster"
	GenerateModeConventional = "conventional"
)

var (
	clusterPackages = []protogen.GoImportPath{
		protogen.GoImportPath("github.com/kercylan98/minotaur/engine/vivid/cluster"),
	}

	conventionalPackages = []protogen.GoImportPath{
		protogen.GoImportPath("github.com/kercylan98/minotaur/engine/vivid"),
	}
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File, mode string) {
	if len(file.Services) == 0 && len(file.Enums) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_typed.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	generateHeader(gen, g, file)
	generateContent(g, file, mode)
}

func generateHeader(gen *protogen.Plugin, g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-minotaur-vivid-typed. DO NOT EDIT.")
	g.P("// versions:")
	g.P("//  protoc-gen-minotaur-vivid-typed ", "1.0.0")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("//  protoc           ", protocVersion)
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
}

func generateContent(g *protogen.GeneratedFile, file *protogen.File, mode string) {
	g.P("package ", "test")
	g.P()
	g.P("var _ *emptypb.Empty")

	switch mode {
	case GenerateModeCluster:
		for _, pkg := range clusterPackages {
			g.QualifiedGoIdent(pkg.Ident(""))
		}
	case GenerateModeConventional:
		for _, pkg := range conventionalPackages {
			g.QualifiedGoIdent(pkg.Ident(""))
		}
	}

	generateServices(g, file)
}

func generateServices(g *protogen.GeneratedFile, file *protogen.File) {
	for _, service := range file.Services {
		generateService(g, service)
	}
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("// ", service.GoName, " is the typed service of ", service.Desc.FullName())

	g.P("type ", service.GoName, " interface {")
	for _, method := range service.Methods {
		generateMethod(g, method)
	}
	g.P("}")
}

func generateMethod(g *protogen.GeneratedFile, method *protogen.Method) {
	g.P("// ", method.GoName, " is the typed method of ", method.Desc.FullName())

	// options
	var (
		hasError = false
		isEmpty  = false
	)

	methodOptions, ok := proto.GetExtension(method.Desc.Options(), options.E_MethodOptions).(*options.MethodOptions)
	if ok && methodOptions != nil {
		hasError = methodOptions.Error
	}

	// check is *emptypb.Empty
	if method.Output.GoIdent.GoImportPath.String() == `"google.golang.org/protobuf/types/known/emptypb"` &&
		g.QualifiedGoIdent(method.Output.GoIdent) == "emptypb.Empty" {
		isEmpty = true
	}

	switch {
	case !isEmpty && !hasError:
		g.P(
			method.GoName,
			"(ctx vivid.ActorContext, message *", g.QualifiedGoIdent(method.Input.GoIdent), ") ",
			"*", g.QualifiedGoIdent(method.Output.GoIdent))
	case !isEmpty && hasError:
		g.P(
			method.GoName,
			"(ctx vivid.ActorContext, message *", g.QualifiedGoIdent(method.Input.GoIdent), ") ",
			"(*", g.QualifiedGoIdent(method.Output.GoIdent), ", error)")
	case isEmpty && !hasError:
		g.P(
			method.GoName,
			"(ctx vivid.ActorContext, message *", g.QualifiedGoIdent(method.Input.GoIdent), ") ")
	case isEmpty && hasError:
		g.P(
			method.GoName,
			"(ctx vivid.ActorContext, message *", g.QualifiedGoIdent(method.Input.GoIdent), ") ",
			"error")
	}
}
